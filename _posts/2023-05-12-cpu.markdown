---
title: "CPU & Memory" #Article title.
date: 2023-05-12
category: [OS, OS] #One, more categories or no at all.
tag: [os]
---

__쉽게배우는 운영체제__

# CPU & MEMORY

## CPU 기본 구성

- 산술논리 연산장치 : 요리사가 재료를 찌거나 볶듯이 CPU에서 데이터를 연산하는 역활(+,-,AND,OR 등)
- 제어장치 : 요리사가 ‘도마를 가져와라’, ‘양파 껍질을 까라’ 와 같이 지시하는 역활
- 레지스터 : 요리에 필요한 재료를 잠시 손에 쥐고 있는 것처럼 데이터를 임시로 보관하는 곳

## 레지스터 종류

- User-visible register
    - CPU는 필요한 데이터를 메모리에서 가져와 레지스터에 저장 하고, 산술논리 연산 장치를 이요해 연산을 한 후, 해당 결과를 다시 레지스터에 저장을 했다가 메모리로 옮기는데, 이때 이용되는 것이 데이터 레지스터와 주소 레지스터
    - 데이터 레지스터 : 메모리에서 가져온 데이터를 임시로 보관할 때 사용, 대부분의 레지스터(일반 & 범용 레지스터)
    - 주소 레지스터 : 데이터, 명령어가 저장된 메모리의 주소
- User-Unvisible register
    - 프로그램 카운터(PC) : CPU는 다음에 어떤 명령어를 처리해야 할지 알아야하고,  다음에 실행할 명령어의 주소를 기억하고 있다가 제어장치에 알려주는 역활
    - 명령어 레지스터(IR) : 현재 실행 중인 명령어를 저장하는 레지스터, 제어장치는  명령어 레지스터에 있는 명령을 해석한 후 외부장치에 제어신호를 보냄
    - 메모리 주소 레지스터(MAR) : 메모리에서 데이터를 가져오거나 반대로 메모리로 데이터를 보낼 때 주소를 지정하기 위해 사용, 메모리 관리자가 접근해야할 메모리의 주소를 저장한다.
        - 명령어를 처리하는 과정에서 필요한 메모리 주소를 이 레지스터에 넣으면 메모리 관리자가 이를 인식하여 해당 메모리 위치의 데이터를 가져오거나 해당 메모리 위치에 데이터를 저장함
    - 메모리 버퍼 레지스터(MBR) : 메모리에서 가져온 데이터나, 보낼 데이터를 임시로 저장하는 곳으로 항상 메모리 주소 레지스터와 함께 동작함
- CPU 명렁어 처리과정  예시
    
    ```c
    int D2=2 , D3=3, sum;
    sum=D2+D3
    
    # 메모리의 100번지(D2)에 있는 값을 레지스터 2 으로 가져옴
    01 LOAD mem(100), register 2;
    # 메모리의 120번지(D3)에 있는 값을 레지스터 3 으로 가져옴
    02 LOAD mem(120), register 3;
    # 레지스터2 + 레지스터3 의 결과값을 레지스터 5에 넣는다
    03 ADD register 5, register 2, register 3;
    # 레지스터 5의 값을 메모리 160번지로 옮긴다
    04 MOVE register 5, mem(160)
    ```
    
    - `LOAD mem(100), register 2` 실행과정
        1. 프로그램 카운터에는 현재 실행중인 코드의 행번호 1 이 저장되고, 이 번호는 제어장치로 전송된다. 이 때, 명령어 레지스터에는 `LOAD` 가 탑재된다.
        2. 제어장치가 명령어 레지스터에 있는 `LOAD` 명령어를 해석해서 메모리에 있는 데이터를 가져오라는 제어신호를 보낸다.
        3. 메모리 주소 레지스터에 100이 저장되고, 메모리 관리자는 메모리의 100번지에 저장된 값(`2`)을 메모리 버퍼 레지스터로 가져온다.
        4. 제어장치는 메모리 버퍼 레지스터에 저장된 값을 레지스터 2 로 옮긴다.

## 메모리의 종류 & 부팅

### RAM(Random Access Memory)

- 휘발성
    - DRAM(동적램) : 저장된 데이터가 일정 시간이 지나면 사라지기에 다시 재생 시켜야함(메인메모리 등), 메인 메모리를 비휘발성 메모리로 사용하면 내부가 복잡하여 속도가 느리고 가격이 비싸기 때문에 휘발성 메모리를 사용한다.
    - SRAM(정적램) : 전력 공급이 되는 동안에는 계속 데이터 보관 가능(캐시 등)
    - SDRAM : DRAM의 진화형태로 클록틱이 발생할 때 마다 데이터를 저장하는 동기 DRAM
- 비휘발성
    - 플래시 메모리
    - FRAM
    - PRAM

### ROM(Read Only Memory)

전력이 끊겨도 데이터를 보관하는 것이 장점이지만, 데이터를 한번 저장하면 바꿀수 없다. 이런 특성 때문에 바이오스를 롬에 저장한다.

- 마스크 롬 : 데이터를 지우거나 쓸 수 없음
- PROM : 전용 기계를 이용해 한 번만 데이터 저장 가능
- EPROM : 데이터를 여러번 지우고 쓸 수 있음, 그래서 플래시 메모리 처럼 사용할 수 있지만 가격이 비쌈

### 메모리 보호

일괄 처리 시스템에서는 메모리가 운영체제 영역과 사용자 영역으로 구분되고, 메모리 보호는 사용자 영역의 작업이 운영체제 영역으로 침범하지 못하도록 막는 것이다.

현대 운영체제는 시분할 기법으로 여러 프로그램을 동시에 실행하기 때문에 사용자 영역이 여러개의 작업 공간으로 나뉘어져 있는데, 메모리 보호가 제대로 되지 않으면 어떤 작업이 다른 영역을 침범하여 해당 영역의 프로그램을 파괴하거나 삭제할 수 있고 운영체제 영역을 침범하면 시스템이 멈출수도 있다.

위와 같이 다른 프로그램 영역으로 악의적으로 침범하여 고장을 일으키는 것을 악성 소프트웨어 바이러스라고 한다.

메모리를 보호하기 위해 CPU는 현재 진행 중인 작업 메모리 시작 주소를 `경계 레지스터`에 저장 한 후 작업한다. 또한 현재 진행죽인 작업이 차지하고 있는 메모리의 크기, 즉 마지막 주소까지의 차이 이를 `한계 레지스터`에 저장한다.

```c
0
			운영체제
100  ----------
			A 작업
140  ---------- -> 경계 레지스터 : 140
			B 작업
180  ---------- -> 한계 레지스터 : 180 - 140 = 40
			C 작업
```

사용자의 작업이 진행되는 동안 이 두 레지스터의 주소 범위를 벗어나는지 하드웨어적으로 점검하면서 메모리를 보호한다. 

위 예시에서 B  작업이 데이터를 읽거나 쓸 때 마다 CPU는 해당 작업이 경계 레지스터와 한계 레지스터의 주소값 안에서 이루어지는지 검사한다.

만약, 두 레지스터 값을 벗어나면 메모리 오류와 관련된 인터럽트가 발생하고, 인터럽트가 발생하면 모든 작업이 중단되고 CPU는 운영체제를 통해 인터럽트를 처리하도록 한다.

### 부팅

응용 프로그램이 운영체제가 메모리에 올려서 실행되는 것 처럼, 운영체제를 메모리에 올리는 과정을 부팅이라고 한다. 

1. 컴퓨터의 전원이 켜지면 ROM에 저장된 바이오스가 실행되고 ,바이오스는 CPU/메모리/하드디스크 등 주요 하드웨어가 잘 작동하는지 확인한다. 이상이 있으면 에러 메세지를 출력하고 없다면 하드디스크의 마스터 부트 레코드(MBR)에 저장된 프로그램을 메모리로 가져와 실행한다.
2. 마스터 부트 레코드는 하드디스크의 첫 번째 섹터를 가리키며, 운영체제를 실행하기 위한 코드인 부트스트랩이 이곳에 저장되어 있다. 부트스트랩은 운영체제를 메모리로 가져와 실행시키는 역확을 하며, 리눅스용 부트스트랩이 실행되면 리눅스 운영체제가 메모리에 올라오고, 윈도우 부트스트랩이면 윈도우 운영체제가 메모리에 올라온다. (os를 USB에 설치하는 것이 USB에 마스터 부트 레코드 영역을 만들고 부트스트랩 코드를 설치하는 것을 뜻한다.)
3. 마스터 부트 레코드에 있는 부트스트랩이 메모리에 올라오면 하드디스크에 저장된 운영체제를 메모리로 불러온다.