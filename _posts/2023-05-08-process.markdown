---
title: "Process & Thread" #Article title.
date: 2023-05-08
category: [OS, OS] #One, more categories or no at all.
tag: [os]
---

__쉽게배우는 운영체제__

# 프로세스

프로그램이 실행된다는 것은 해당 코드가 메모리에 올라와서 작업이 진행된다는 의미이다. 프로그램은 저장장치에 저장되어 잇는 정적인 상태이고, 프로세스는 실행을 위해 메모리에 올라온 동적인 상태이다.

- 프로그램 → 프로세스
    - 프로그램을 실행 시킬 때 운영체제는 프로그램을 메모리로 가져오고 그와 동시에 작업 지시서에 해당하는 PCB(프로세스 제어 블록)을 만든다.
    - 즉, 프로그램이 프로세스가 되었다는 것은 PCB를 받았다는 것
- PCB 구성요소 중 대표적인 3가지
    - 프로세스 구분자(PID) : 메모리에는 여러 개의 프로세스가 존재하고 이들을 구분하는 구분자(ID)가 있다
    - 메모리 관련 정보 : CPU가 실행하려는 프로세스가 메모리 어디에 저장 되어 있는지 알기 위한 메모리 위치정보와 보호를 위한 경계 레지스터, 한계 레지스터 값 등
    - 각종 중간값 : 시분할 시스템에서는 여러 프로세스가 번갈아 실행되기 때문에, 다음에 작업해야 할 코드의 위치가 담긴 레지스터인 프로그램 카운터가 저장되고 작업의 중간값을 보관 중인 다른 레지스터도 함께 저장된다.

PCB는 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조이기 때문에 운영체제 영역에 만들어지고, 프로세스가 종료되면 메모리에서 프로세스와 함께 삭제된다.

## 프로세스 상태

- 생성 상태
    - 프로세스가 메모리에 올라오고 운영체제로부터 PCB를 할당 받은 상태
    - 생성된 프로세스는 PCB와 함께 준비 상태로 옮겨짐
- 준비 상태
    - 생성된 프로세스가 CPU를 얻을 때 까지 기다리는 상태
    - 준비 상태에 있는 프로세스 중 다음에 실행할 프로세스는 CPU 스케쥴러가 정해주고, CPU 스케줄러는 맨 앞에 있는 PCB를 CPU에게 전달하여 작업이 이어지게 한다.
    - 이렇게 준비 상태의 프로세스 중 하나를 실행 상태로 바꾸는 CPU 스케줄러의 작업을 dispatch 라고 한다.
- 실행 상태
    - 준비 상태의 프로세스들 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태
    - 실행 상태가 된 프로세스는 일정 시간 동안 CPU를 사용할 권리를 얻는다. 주어진 시간을 다 사용하고도 작업을 끝내지 못하면 준비 상태로 돌아와 다음 차례를 기다린다.
    - CPU를 사용할 권리를 얻은 시간을 타임 퀸텀, 타임 슬라이스 라고 부름
- 완료 상태
    - 실행 상태의 프로세스가 주어진 시간 동안에 작업을 완료한 상태
- 대기 상태
    - 입출력관리자에게 입출력을 요구한 프로세스가 입출력이 완료될 때 까지 기다리는 상태, 효율성을 높이기 위해 입출력 요청 후 기다리는 중인 프로세스를 실행 상태로 두지 않음
    - 대기 상태의 프로세스는 요청한 입출력이 완료되면 입출력 관리자로부터 인터럽트를 받고, 바로 실행 상태로 가는게 아니라 준비 상태로 돌아가 자기 차례를 기다림

| 상태 | 설명 | 작업 |
| --- | --- | --- |
| 생성 상태 | 프로그램을 메모리에 가져와 실행 준비가 완료된 상태 | 메모리 할당, PCB 생성 |
| 준비 상태 | 실행을 기다리는 프로세스 중 CPU 스케줄러가  선택 | dispatch(PID): 준비 → 실행 |
| 실행 상태 | 선택된 프로세스가 타임 퀸텀을 얻어 CPU를 사용하는 상태 | timeout : 실행 → 준비
exit : 실행 → 완료
block : 실행 → 대기 |
| 대기 상태 | 실행 상태의 프로세스가 입출력을 요구하고 완료를 기다리는 상태, 입출력이 완료되면 준비 상태가 된다 | wakeup : 대기 → 준비 |
| 완료 상태 | 프로세스가 종료된 상태, 사용하던 모든 데이터가 정리됨 | 메모리, PCB 삭제 |

## PCB

프로세스 제어블록 구성

- 포인터 : 준비 상태, 대기상태는 Queue로 운영되고, 이를 구현 할 때 포인터를 사용
- 프로세스 상태 : 현재 프로세스가 어떤 상태인지 나타내고, PCB의 두번째 블록에 저장된다
- 프로세스 구분자 : PID, 여러 프로세스를 구별하기 위한 구별자
- 프로그램 카운터 : 다음 실행될 명령어의 위치를 가리키는 프로그램 카운터의 값 저장
- 프로세스 우선순위 : 다양한 우선순위의 프로세스가 대기 상태로 들어오기 때문에 대기 상태의 큐도 우선순위 별로 따로 운영된다. 즉, 우선순위에 따라 PCB가 여러 줄로 서있다. CPU 스케줄러가 준비 상태에 있는 프로세스를 선택할 때, 프로세스 우선순위를 기준으로 삼는다.
- 각종 레지스터 정보 : 프로세스가 실행되는 중에 사용하던 레지스터의 값이 저장된다. 이전에 실행할 때 사용한 레지스터의 값을 보관해야 다음에 실행할 수 있기 때문에, 자신이 사용하던 레지스터의 중간값을 보관한다.
- 메모리 관리 정보 : 프로세스가 메모리의 어디에 있는지 나타내는 메모리 위치정보, 메모리 보호를 위해 사용되는 한계 레지스타 값, 경계레지스터 값 등이 저장된다. 그리고 세그먼테이션 테이블, 페이지 테이블 등의 정보도 보관된다.
- 할당된 자원 정보 : 프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보

## Context Switching

CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업으로, 이 때 두 프로세스의 PCB 내용이 변경된다.

# 프로세스 연산

## 프로세스 구조

- 코드영역
    - 프로그램의 본문이 기술된 곳으로, 프로그래머가 작성한 프로그램은 코드영역에 탑재되며 탑재된 코드는 읽기 전용으로 처리 된다
- 데이터영역
    - 코드가 실행되면서 사용하는 변수,파일 등의 각종 데이터를 모아두는 곳이다. 데이터는 변하는 값이기 때문에 이 영역은 읽기/쓰기 가능
- 스택 영역
    - 운영체제가 프로세스를 실행하기 위해 사용하는 부수적인 데이터를 모아두는 곳. 예를들어 함수를 호출하면 함수를 수행하고 원래 프로그램으로 되돌아갈 위치를 이 영역에 저장한다.

예를들어 엑셀을 실행하면, 이 프로그램은 코드 영역에 탑재되고 엑셀로 편집 중인 문서는 데이터 영역에 탑재된다. 또한, 운영체제가 엑셀을 작동하기 위해서 사용하는 각종 부가 데이터는 스택 영역에서 관리한다.

## 프로세스 생성과 복사

- `fork()`
    - 실행 중인 프로세스로 부터 새로운 프로세스를 복사하는 함수
    - 엑셀에서 문서작업을 하다가 새로운 엑셀을 하나 더 실행하면, 새로운 엑셀을 실행하는게 아니라 기존에 사용중이던 엑셀을 복사한다.
    - PCB를 포함한 부모 프로세스의 대부분이 복사되지만 PID,메모리 관련 정보 등은 변경 된다


# 스레드

- 프로세스의 작업 과정
    - 운영체제는 코드,데이터를 메모리로 가져오고 PCB 생성 후 작업에 필요한 메모리 영역을 확보하여 준비된 프로세스를 큐에 삽입함
    - 프로세스가 생성되면 CPU 스케줄러는 프로세스가 해야 할 일을 CPU에  전달하고 CPU는 작업 수행하는데, 이 때 CPU스케줄러가 CPU에 전달하는 일 하나가 스레드 이다
    - 운영체제 입장에서 작업 단위는 프로세스, CPU 입장에서 작업 단위는 스레드
    - `즉, 스레드는 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행단위`
    
- 멀티 스레드
    - 프로세스 내 작업을 여러개의 스레드로 분할해서 작업의 부담을 줄이는 프로세스 운영 기법
- 멀티 태스킹
    - 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법
- 멀티 프로세싱
    - CPU 여러 개를 사용해서 여러 개의 스레드를 동시에 처리하는 작업 환경
    - 하나의 컴퓨터에 여러 개의 CPU 혹은 하나의 CPU 내 여러 개의 코어에 스레드를 배정하여 동시에 작동하게 하는 것

## 멀티 스레드

기존에 멀티 태스킹 방식으로 어러개의 작업을 처리하려면, fork() 시스템 호출을 사용하여 동일한 프로세스를 생성하거나, exec() 시스템 호출로 프로세스를 전환하는 방법을 이용했다.

프로세스에는 실행되는 동안 값이 바뀌지 않는 정적 영역과 작업 중 값이 바뀌게 되는 레지스터 값, 스택, 힙 등이 있는 동적 영역이 있는데 fork() 호출은 필요없는 정적 영역까지 복사하게 되어낭비적인 요소가 많다. 

스레드는 이런 멀티 태스킹의 낭비 요소를 제거하기 위해 사용 된다. 2개의 프로세스를 만드는 대신 코드,데이터 등을 공유하면서 여러 개의 일을 하나의 프로세스 내에서 하는 것이다.

예를들어 비디오 플레이어를 봣을 때 재생할 파일을 저장장치로 가져오는 입출력 부분과 가져온 데이터를 화면에 재생하는 부분으로 나뉜다. 

이 기능을 단일 스레드로 구현하면 입출력을 요청한 프로세스는 입출력이 완료될 때 까지 대기 상태로 전환된다. 그래서 요청한 입출력이 끝나야만 다시 재생이 가능하다.

하지만 멀티 스레드로 구현한다면 스레드가 독립적으로 작동하기 때문에 입출력 스레드가 대기 상태에 있더라도 재생 스레드는 실행 상태에 있게 되므로, 입출력 상태와 상관없이 재생이 가능하다.

- 멀티 스레드 장점
    - 응답성 향상 : 한 스레드가 입출력 작업 중이더라도, 다른 스레드가 작업을 계속해서 사용자의 작업 요구에 빠르게 대응 가능하다
    - 자원 공유 : 한 프로세스 내에서 스레드를 생성하면, 프로세스가 가진 모든 자원을 스레드가 공유한다
    - 효율성 향상 : 여러 개의 프로세스를 생성하는 것과 달리 멀티 스레드는 불필요한 자원의 낭비를 줄인다
- 멀티 스레드 단점
    - 모든 스레드가 해당 프로세스의 자원을 공유하기 때문에, 한 스레드에 문제가 생기면 전체 프로세스에 영향을 끼침